



───────────── app.ts ─────────────
import express, { NextFunction, Request, Response } from "express";
import helmet from "helmet";
import cors from "cors";

import { env } from "./config/env.js";
import apiRouter from "./routes/api.js";
import { globalLimiter } from "./middleware/globalLimiter.js";

const app = express();
app.disable("x-powered-by");

app.use(helmet());
app.use(
  cors({
    origin: "*",
    credentials: false,
  })
);

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use(globalLimiter);

app.get("/health", (_req: Request, res: Response) => {
  res.status(200).json({
    status: "OK",
    uptime: process.uptime(),
    timestamp: new Date().toISOString(),
  });
});

app.use("/api", apiRouter);

app.use((_req: Request, res: Response) => {
  res.status(404).json({
    status: "error",
    message: "Not found",
  });
});

app.use((err: unknown, _req: Request, res: Response, _next: NextFunction) => {
  console.error(err);

  const message = err instanceof Error ? err.message : "Internal Server Error";

  res.status(500).json({
    status: "error",
    message,
    ...(process.env.NODE_ENV !== "production" && {
      stack: err instanceof Error ? err.stack : undefined,
    }),
  });
});

export default app;


───────────── env.ts ─────────────
import { cleanEnv, str, num } from 'envalid';

export const env = cleanEnv(process.env, {
  // DATABASE
  DB_HOST: str({ default: 'localhost' }),
  DB_PORT: num({ default: 3306 }),
  DB_DATABASE: str({ default: 'dbauth' }),
  DB_USERNAME: str({ default: 'root' }),
  DB_PASSWORD: str({ default: 'admin' }),

  // SERVER
  PORT: num({ default: 5000 }),

  // URL
  FRONTEND_URL: str({ default: 'http://localhost:3000' }),

  // CORS
  CORS_EXPIRES: num({ default: 3600 }),

  // NODE_ENV
  NODE_ENV: str({ choices: ['development', 'production'], default: 'development' }),
});


───────────── lobbyHandlers.ts ─────────────
// handlers/lobbyHandlers.ts
import { Request, Response } from "express";
import { v4 as uuidv4 } from "uuid";
import { Lobby } from "../types/types.js"; // zakładam, że masz typ Lobby
import logger from "src/utils/logger.js";

// tymczasowa pamięć na lobby
const lobbies: Lobby[] = [];

/**
 * Pobierz wszystkie lobby
 */
export const getAllLobbies = (_req: Request, res: Response) => {
  res.json({ success: true, data: lobbies });
};

/**
 * Utwórz nowe lobby
 */
export const createLobby = (req: Request, res: Response) => {
  logger.info(`${JSON.stringify(req.body)}`);
  const { nick, lobbyName, maxPlayers = 2, useBots = true } = req.body;

  if (!nick || !lobbyName) {
    return res
      .status(400)
      .json({ success: false, error: "Missing nick or lobbyName" });
  }

  // ✅ Sprawdzenie, czy lobby o tej nazwie już istnieje
  const exists = lobbies.some((l) => l.name === lobbyName);
  if (exists) {
    return res
      .status(400)
      .json({ success: false, error: "Lobby name already exists" });
  }

  // ✅ Generujemy unikalny identyfikator
  const lobbyId = uuidv4();

  const lobby: Lobby = {
    id: lobbyId, // nowy UUID
    name: lobbyName,
    players: [nick],
    maxPlayers,
    useBots,
    started: false,
    host: nick,
  };

  lobbies.push(lobby);
  logger.info(`lobby created: ${JSON.stringify(lobby)}`);

  // Wyślij aktualizację do wszystkich klientów WS
  const wss = req.app.get("wss");
  if (wss?.clients) {
    wss.clients.forEach((client: any) => {
      if (client.readyState === 1) {
        client.send(JSON.stringify({ type: "lobby_list_update", lobbies }));
      }
    });
  }

  // Zwracamy lobby z UUID do frontendu
  res.json({ success: true, data: lobby });
};

/**
 * Dołącz do lobby
 */
export const joinLobby = (req: Request, res: Response) => {
  const { nick } = req.body;
  const { id } = req.params; // teraz id zamiast name

  const lobby = lobbies.find((l) => l.id === id);
  if (!lobby)
    return res.status(404).json({ success: false, error: "Lobby not found" });

  let finalNick = nick?.trim();
  if (!finalNick) {
    // generowanie unikalnego guest nick w tym lobby
    let i = 1;
    do {
      finalNick = `Guest-${Math.floor(Math.random() * 10000)}`;
      i++;
    } while (lobby.players.includes(finalNick) && i < 10);
  }

  if (lobby.players.includes(finalNick))
    return res
      .status(400)
      .json({ success: false, error: "Nick already taken" });

  if (lobby.players.length >= lobby.maxPlayers)
    return res.status(400).json({ success: false, error: "Lobby full" });

  lobby.players.push(finalNick);

  // Aktualizacja WS
  // Po dodaniu gracza do lobby
  const wss = req.app.get("wss");
  if (wss?.clients) {
    wss.clients.forEach((client: any) => {
      if (client.readyState === 1) {
        client.send(
          JSON.stringify({
            type: "lobby_update",
            lobby, // tylko to jedno lobby
          })
        );
      }
    });
  }

  res.json({ success: true, data: lobby, nick: finalNick });
};

/**
 * Opuść lobby
 */
export const leaveLobby = (req: Request, res: Response) => {
  const { nick } = req.body;
  const { name } = req.params;

  const lobby = lobbies.find((l) => l.name === name);
  if (!lobby)
    return res.status(404).json({ success: false, error: "Lobby not found" });

  lobby.players = lobby.players.filter((p) => p !== nick);

  // Jeżeli lobby puste, usuń je
  if (lobby.players.length === 0) {
    const index = lobbies.findIndex((l) => l.name === name);
    lobbies.splice(index, 1);
  }

  // Aktualizacja WS
  const wss = req.app.get("wss");
  if (wss?.clients) {
    wss.clients.forEach((client: any) => {
      if (client.readyState === 1) {
        client.send(JSON.stringify({ type: "lobby_list_update", lobbies }));
      }
    });
  }

  res.json({ success: true, data: lobby || null });
};


/**
 * Start gry
 */
export const startGame = (req: Request, res: Response) => {
  const { id } = req.params;
  const lobby = lobbies.find(l => l.id === id);
  if (!lobby) {
    return res.status(404).json({ success: false, error: "Lobby not found" });
  }

  // Sprawdzenie minimalnej liczby graczy
  if (!lobby.useBots && lobby.players.length < 2) {
    return res.status(400).json({ success: false, error: "Not enough players to start the game" });
  }

  lobby.started = true;

  // Wyślij aktualizację tylko graczom w tym lobby
  const wss = req.app.get("wss");
  if (wss?.clients) {
    wss.clients.forEach((client: any) => {
      if (client.readyState !== 1) return;
      if (client.lobbyId === id) {
        client.send(JSON.stringify({ type: "game_started", lobby }));
      }
    });
  }

  res.json({ success: true, lobby });
};


───────────── index.ts ─────────────
import http from "http";
import app from "./app.js";
import { env } from "./config/env.js";
import { setupWebSocket } from "./server/ws/wsServer.js";

const PORT = env.PORT || 5000;

const server = http.createServer(app);

// konfiguracja WS
const wss = setupWebSocket(server);
app.set("wss", wss);

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT} [${env.NODE_ENV}]`);
});


───────────── globalLimiter.ts ─────────────
import rateLimit from 'express-rate-limit';

// Limiter globalny dla całego API
export const globalLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minuta
  max: 60,             // maksymalnie 60 żądań na IP na minutę
  standardHeaders: true, // zwraca limit info w headerach `RateLimit-*`
  legacyHeaders: false,  // wyłącza X-RateLimit-*
  message: {
    status: 'error',
    message: 'Za dużo żądań. Spróbuj ponownie później.'
  }
});


───────────── api.ts ─────────────
import { Router } from "express";
import { 
  createLobby, 
  getAllLobbies, 
  joinLobby, 
  leaveLobby, 
  startGame 
} from "src/handlers/lobbyHandlers.js";

const router = Router();

// --- Lobby ---
router.get("/lobbies", getAllLobbies);          // pobierz wszystkie lobby
router.post("/lobbies", createLobby);           // utwórz nowe lobby
router.post("/lobbies/:id/join", joinLobby);    // dołącz do lobby
router.post("/lobbies/:id/start", startGame);   // rozpocznij grę
router.post("/lobbies/:id/leave", leaveLobby);  // opuść lobby

// --- Blackjack / przyszłe endpointy ---
// router.post("/lobbies/:id/deal");
// router.post("/lobbies/:id/hit");
// router.post("/lobbies/:id/stand");
// router.post("/lobbies/:id/reset");

export default router;


───────────── data.ts ─────────────
// src/data/lobbies.ts
import type { Lobby } from "../../types/types.js";
import { GameService } from "../ws/services/gameService.js";

export const lobbies: Lobby[] = [];
export const games: Record<string, GameService> = {};

───────────── gameHandler.ts ─────────────
import logger from "src/utils/logger.js";
import { GameService } from "../services/gameService.js";
import { games } from "src/server/data/data.js";
 
export const handleGameMessage = (ws: any, wss: any, msg: any) => {
  logger.info(
    `[GAME_MESSAGE] Typ: ${msg.type}, od: ${ws.nick || "unknown"}, lobbyId: ${
      msg.lobbyId
    }`
  );

  switch (msg.type) {
    case "start_game":
      logger.info(`[START_GAME] Próba startu gry dla lobby: ${msg.lobbyId}`);

      lobby.started = true;

      // Tworzymy nowy serwis gry i zapisujemy w globalnym obiekcie
      const playerNicks = Array.from(wss.clients)
        .filter((c: any) => c.lobbyId === msg.lobbyId)
        .map((c: any) => c.nick);

      const gameService = new GameService(msg.lobbyId, playerNicks);
      games[msg.lobbyId] = gameService;

      // Rozsyłamy stan gry do wszystkich w lobby
      wss.clients.forEach((client: any) => {
        if (client.readyState !== 1 || client.lobbyId !== msg.lobbyId) return;

        // publiczny stan
        const publicState = gameService.getPublicState(client.nick);
        client.send(
          JSON.stringify({ type: "game_state_public", gameState: publicState })
        );

        // prywatny stan (karty gracza)
        const privateHand = gameService.getPrivateHand(client.nick);
        client.send(
          JSON.stringify({ type: "game_state_private", hand: privateHand })
        );

        logger.info(`[START_GAME] Wysłano game_state do: ${client.nick}`);
      });
      break;

    case "subscribe_to_game":
      ws.lobbyId = msg.lobbyId;
      ws.send(
        JSON.stringify({ type: "subscribed_to_game", lobbyId: msg.lobbyId })
      );
      logger.info(
        `[SUBSCRIBE_TO_GAME] Klient ${ws.nick} subskrybuje grę w lobby: ${msg.lobbyId}`
      );
      break;

    case "player_action":
      const service = games[msg.lobbyId];
      if (!service) {
        logger.warn(`[PLAYER_ACTION] Brak gry dla lobby ${msg.lobbyId}`);
        return;
      }

      // TODO: implementacja hit/stand/double itp.
      logger.info(
        `[PLAYER_ACTION] Akcja od ${ws.nick} w lobby ${
          msg.lobbyId
        }: ${JSON.stringify(msg.action)}`
      );

      // przykładowo po akcji można odświeżyć public/private state
      wss.clients.forEach((client: any) => {
        if (client.readyState !== 1 || client.lobbyId !== msg.lobbyId) return;
        client.send(
          JSON.stringify({
            type: "game_state_public",
            gameState: service.getPublicState(client.nick),
          })
        );
        client.send(
          JSON.stringify({
            type: "game_state_private",
            hand: service.getPrivateHand(client.nick),
          })
        );
      });
      break;

    default:
      logger.warn(
        `[GAME_MESSAGE] Nieobsługiwany typ wiadomości: ${msg.type} od ${ws.nick}`
      );
  }
};


───────────── lobbyHandler.ts ─────────────
import { lobbies } from "../../data/lobbies.js";
import { MyWebSocket } from "../types/types.js";
import logger from "src/utils/logger.js";

export const handleLobbyMessage = (ws: MyWebSocket, wss: any, msg: any) => {
  switch (msg.type) {
    case "create_lobby":
      logger.info(`[CREATE_LOBBY] Próba utworzenia lobby przez: ${msg.nick}`);

      const existingLobby = lobbies.find((l) => l.players.includes(msg.nick));
      if (existingLobby) {
        logger.warn(
          `[CREATE_LOBBY] ${msg.nick} jest już w lobby ${existingLobby.id}`
        );
        ws.send(
          JSON.stringify({
            type: "error",
            message: "You are already in a lobby",
          })
        );
        return;
      }

      const newLobby = {
        id: crypto.randomUUID(),
        name: msg.lobbyName,
        players: [msg.nick],
        maxPlayers: msg.maxPlayers || 2,
        useBots: msg.useBots ?? true,
        started: false,
        host: msg.nick,
      };
      lobbies.push(newLobby);
      logger.info(
        `[CREATE_LOBBY] Lobby utworzone: ${JSON.stringify(newLobby, null, 2)}`
      );

      ws.lobbyId = newLobby.id;
      ws.nick = msg.nick;

      ws.send(
        JSON.stringify({
          type: "joined_lobby",
          nick: msg.nick,
          lobby: newLobby,
        })
      );
      logger.info(`[CREATE_LOBBY] Wysłano joined_lobby do twórcy: ${msg.nick}`);

      broadcastLobbyList(wss);
      logger.info(`[CREATE_LOBBY] Wysłano broadcastLobbyList do wszystkich`);
      break;

    case "join_lobby":
      logger.info(
        `[JOIN_LOBBY] Próba dołączenia: ${msg.nick} do lobby: ${msg.lobbyId}`
      );

      const lobbyToJoin = lobbies.find((l) => l.id === msg.lobbyId);
      if (!lobbyToJoin) {
        logger.warn(`[JOIN_LOBBY] Lobby ${msg.lobbyId} nie istnieje`);
        ws.send(JSON.stringify({ type: "error", message: "Lobby not found" }));
        return;
      }

      if (lobbyToJoin.players.includes(msg.nick)) {
        logger.warn(`[JOIN_LOBBY] ${msg.nick} już jest w lobby ${msg.lobbyId}`);
        ws.send(
          JSON.stringify({
            type: "error",
            message: "You are already in this lobby",
          })
        );
        return;
      }

      lobbyToJoin.players.push(msg.nick);
      ws.lobbyId = lobbyToJoin.id;
      ws.nick = msg.nick;

      logger.info(`[JOIN_LOBBY] ${msg.nick} dołączył do lobby: ${msg.lobbyId}`);
      logger.info(
        `[JOIN_LOBBY] Aktualni gracze: ${JSON.stringify(lobbyToJoin.players)}`
      );

      // wysyłamy pełny stan lobby do wszystkich w lobby
      broadcastLobbyUpdate(wss, lobbyToJoin);
      logger.info(
        `[JOIN_LOBBY] Wysłano broadcastLobbyUpdate dla lobby: ${msg.lobbyId}`
      );

      ws.send(
        JSON.stringify({
          type: "joined_lobby",
          nick: msg.nick,
          lobby: lobbyToJoin,
        })
      );
      logger.info(
        `[JOIN_LOBBY] Wysłano joined_lobby do dołączającego: ${msg.nick}`
      );
      break;

    case "leave_lobby":
      logger.info(`[LEAVE_LOBBY] ${msg.nick} opuszcza lobby: ${msg.lobbyId}`);

      const leaveLobby = lobbies.find((l) => l.id === msg.lobbyId);
      if (!leaveLobby) {
        logger.warn(`[LEAVE_LOBBY] Nie znaleziono lobby ${msg.lobbyId}`);
        return;
      }

      logger.info(
        `[LEAVE_LOBBY] Przed opuszczeniem gracze: ${JSON.stringify(
          leaveLobby.players
        )}`
      );

      // Usuwamy gracza z listy
      leaveLobby.players = leaveLobby.players.filter((p) => p !== msg.nick);

      // Jeśli opuszczający był hostem i są inni gracze, wybieramy nowego hosta
      if (leaveLobby.host === msg.nick && leaveLobby.players.length > 0) {
        leaveLobby.host = leaveLobby.players[0]; // kolejność według tablicy
        logger.info(`[LEAVE_LOBBY] Nowy host: ${leaveLobby.host}`);
      }

      logger.info(
        `[LEAVE_LOBBY] Po opuszczeniu gracze: ${JSON.stringify(
          leaveLobby.players
        )}`
      );

      // Jeśli lobby puste, usuwamy je
      if (leaveLobby.players.length === 0) {
        const index = lobbies.findIndex((l) => l.id === leaveLobby.id);
        lobbies.splice(index, 1);
        logger.info(
          `[LEAVE_LOBBY] Lobby ${leaveLobby.id} usunięte (brak graczy)`
        );
      }

      // Broadcast aktualnej listy lobby wszystkim klientom
      broadcastLobbyList(wss);
      logger.info(`[LEAVE_LOBBY] Wysłano broadcastLobbyList`);

      // Broadcast aktualizacji samego lobby dla pozostających graczy
      if (leaveLobby.players.length > 0) {
        broadcastLobbyUpdate(wss, leaveLobby);
        logger.info(
          `[LEAVE_LOBBY] Wysłano broadcastLobbyUpdate dla lobby: ${leaveLobby.id}`
        );
      }

      // Informacja dla opuszczającego gracza
      ws.send(
        JSON.stringify({
          type: "left_lobby",
          lobbyId: msg.lobbyId,
          nick: msg.nick,
        })
      );
      logger.info(`[LEAVE_LOBBY] Wysłano left_lobby do gracza ${msg.nick}`);
      break;

    case "ping_lobbies":
      ws.send(JSON.stringify({ type: "lobby_list_update", lobbies }));
      logger.info(`[PING_LOBBIES] Wysłano lobby_list_update`);
      break;
  }
};

// helpery
function broadcastLobbyList(wss: any) {
  wss.clients.forEach((c: MyWebSocket) => {
    if (c.readyState === c.OPEN)
      c.send(JSON.stringify({ type: "lobby_list_update", lobbies }));
  });
}

function broadcastLobbyUpdate(wss: any, lobby: any) {
  wss.clients.forEach((c: MyWebSocket) => {
    if (c.readyState === c.OPEN && lobby.players.includes(c.nick!)) {
      c.send(JSON.stringify({ type: "lobby_update", lobby }));
    }
  });
}


───────────── deck.ts ─────────────
import type { Card } from "../../../types/types.js";

export const generateDeck = (): Card[] => {
  const suits: Card["suit"][] = ["Hearts", "Diamonds", "Clubs", "Spades"];
  const values: Card["value"][] = [
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "10",
    "J",
    "Q",
    "K",
    "A",
  ];
  const deck: Card[] = [];
  for (const suit of suits) {
    for (const value of values) {
      deck.push({ suit, value });
    }
  }
  return deck.sort(() => Math.random() - 0.5); // tasowanie
};


───────────── gameService.ts ─────────────
import type { GameState, PlayerState } from "../../../types/types.js";
import { generateDeck } from "./deck.js";

export class GameService {
  private state: GameState;

  constructor(lobbyId: string, players: string[]) {
    const deck = generateDeck();
    const playerHands: Record<string, PlayerState> = {};

    players.forEach((nick) => {
      playerHands[nick] = {
        nick,
        hand: [deck.pop()!, deck.pop()!],
        score: 0,
        status: "waiting",
        bet: 0,
        balance: 1000, // startowy balans
      };
    });

    const dealer = { hand: [deck.pop()!, deck.pop()!], score: 0 };

    this.state = {
      lobbyId,
      players: playerHands,
      dealer,
      currentPlayerNick: players[0],
      gameStatus: "player_turn",
      winner: null,
      deck,
    };
  }

  getState(): GameState {
    return this.state;
  }

  getPublicState(forNick: string) {
    const { players, dealer, lobbyId, currentPlayerNick, gameStatus, winner } =
      this.state;
    return {
      lobbyId,
      players: Object.fromEntries(
        Object.entries(players).map(([n, p]) => [
          n,
          { score: p.score, status: p.status },
        ])
      ),
      dealer: { hand: ["?", dealer.hand[1]], score: dealer.score },
      currentPlayerNick,
      gameStatus,
      winner,
    };
  }

  getPrivateHand(nick: string) {
    return this.state.players[nick].hand;
  }

  // TODO: metody typu hit(), stand(), double(), updateScores(), nextTurn(), endGame()
}


───────────── types.ts ─────────────
// ws/handlers/types.ts
import { WebSocket } from "ws";

export interface MyWebSocket extends WebSocket {
  nick?: string;
  lobbyId?: string;
}


───────────── wsServer.ts ─────────────
import { Server as HttpServer } from "http";
import { Server, WebSocketServer } from "ws";
import { handleLobbyMessage } from "./handlers/lobbyHandler.js";
import { handleGameMessage } from "./handlers/gameHandler.js";

export const setupWebSocket = (server: HttpServer) => {
  const wss = new WebSocketServer({ server, path: "/ws" });

  wss.on("connection", (ws: any) => {
    console.log("New WS connection");

    ws.on("message", (msg: string) => {
      let data;
      try {
        data = JSON.parse(msg);
      } catch {
        return;
      }

      switch (data.type) {
        case "create_lobby":
        case "join_lobby": 
        case "joined_lobby":
        case "leave_lobby": 
        case "ping_lobbies":
        case "lobby_update":
          handleLobbyMessage(ws, wss, data);
          break;
        case "start_game":
        case "player_action":
        case "subscribe_to_game": 
          handleGameMessage(ws, wss, data);
          break;
        default:
          console.warn("Unknown WS message type:", data.type);
      }
    });

    ws.on("close", () => console.log("Client disconnected"));
  });

  return wss;
};


───────────── types.ts ─────────────
// src/types.ts
// #region LOBBY
export interface Lobby {
  id: string;            // UUID v4
  name: string;          // unikalna nazwa lobby
  players: string[];     // lista nicków graczy
  maxPlayers: number;    // maksymalna liczba graczy
  useBots: boolean;      // czy wypełniać pustki botami
  started: boolean;      // czy gra się rozpoczęła
  host: string;          // nick hosta
}
// 
// #region GAME
// src/types.ts (albo osobny plik gameTypes.ts)
export interface Card {
  suit: 'Hearts' | 'Diamonds' | 'Clubs' | 'Spades';
  value: '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | 'J' | 'Q' | 'K' | 'A';
}

export interface PlayerState {
  nick: string;
  hand: Card[];           // karty gracza
  score: number;          // aktualny wynik
  status: 'waiting' | 'player_turn' | 'stand' | 'bust'; // status w grze
}

export interface DealerState {
  hand: Card[];
  score: number;
}

export type GameStatus = 'waiting_for_players' | 'player_turn' | 'dealer_turn' | 'finished';

export interface GameState {
  lobbyId: string;                       // powiązanie z konkretnym lobby
  players: Record<string, PlayerState>;  // każdy gracz po nicku
  dealer: DealerState;
  currentPlayerNick: string | null;      // nick aktualnego gracza
  gameStatus: GameStatus;
  winner: string | 'push' | null;        // zwycięzca po zakończeniu
  deck: Card[];                           // talia kart pozostała do rozdania
}



───────────── logger.ts ─────────────
import { transports, createLogger, format, Logger } from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import { env } from 'process';

// Definicja poziomów logowania z typami
const logLevels: Record<string, number> = {
  error: 0,
  warn: 1,
  info: 2,
  debug: 3,
};

// Personalizacja kolorów
const customColors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  debug: 'cyan',
};
format.colorize().addColors(customColors);

// Format dla konsoli z kolorami
const consoleFormat = format.combine(
  format.colorize({ all: true }), // Kolory dla wszystkich poziomów
  format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  format.printf(({ timestamp, level, message, ...meta }) => {
    return `${timestamp} [${level}]: ${message} ${
      Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''
    }`;
  })
);

// Format dla plików (bez kolorów, JSON)
const fileFormat = format.combine(
  format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
  format.json()
);

// Interfejs dla loggera z metodą debugObject
interface CustomLogger extends Logger {
  debugObject: (message: string, object: any) => void;
}

// Tworzenie loggera
const logger: CustomLogger = createLogger({
  levels: logLevels,
  level: env.NODE_ENV === 'development' ? 'debug' : 'info',
  format: fileFormat,
  transports: [
    new transports.Console({
      format: consoleFormat,
    }),
    new DailyRotateFile({
      filename: 'logs/app-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '10m',
      maxFiles: '14d',
      format: fileFormat,
    }),
    new DailyRotateFile({
      level: 'error',
      filename: 'logs/error-%DATE%.log',
      datePattern: 'YYYY-MM-DD',
      zippedArchive: true,
      maxSize: '10m',
      maxFiles: '30d',
    }),
  ],
  exceptionHandlers: [new transports.File({ filename: 'logs/exceptions.log' })],
  rejectionHandlers: [new transports.File({ filename: 'logs/rejections.log' })],
}) as CustomLogger;

// Dodanie metody debugObject (loguje tylko gdy poziom to debug lub niższy)
logger.debugObject = (message: string, object: any): void => {
  const levelNum = logLevels[logger.level] ?? 2; // default info=2
  if (levelNum >= logLevels.debug) {
    logger.debug(message, { object: JSON.stringify(object, null, 2) });
  }
};

export default logger;


